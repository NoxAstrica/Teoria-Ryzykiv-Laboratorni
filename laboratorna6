#include <iostream>
#include <iomanip>
#include <cmath>

using namespace std;

const int n = 4;

float x[n] = {};

float p[n] = {};

int F_minus[n][n] = { {5, 10, 18, 25},
            {8, 7, 8, 23},
            {21, 18, 12, 21},
            {30, 22, 19, 15}};
        
//////////////////////////////
            
void bernulli_laplace(float p[n]) { //for I4
    for (int i = 0; i < n; i++) {
        p[i] = 1/n;
    }
}

void bayes() { //after bernulli_laplace, I4

}

void avsquare_variation() { //after bernulli_laplace, I4
}



void wald(float F[n][n], float B[n]) { //for I5. max because F-

    for (int k = 0; k < n; k++) {

        float max = F[k][0];

        for (int j = 1; j < n; j++) {

            if (F[k][j] > max) max = F[k][j];

        }

        B[k] = max;
    }

    // float min = B[0];
    // //??????????????????????
    // for (int k = 0; k < n - 1; k++) {
    //     if (B[k] < min) min = B[k];
    // }
    
    // returnm min;
    
}

///////////////////////

void change_ingredient_norm(float F[n], float Fmod[n]) { 

    for (int i = 0; i < n; i++) {
        Fmod[i] = -F[i];
    }

}

void dependable_norm(float F[n], float Fmod[n]) { //with min
    float min = F[0];

    for (int i = 0; i < n; i++) {
        if (F[i] < min) min = F[i];
    }
        
    for (int i = 0; i < n; i++) {
        Fmod[i] = F[i] / min;
    }
}

void savidzh(float F[n], float Fmod[n]) {

    float min = F[0];
    float max = F[0];

    for (int i = 0; i < n; i++) {
        if (F[i] < min) min = F[i];
    }

    for (int i = 0; i < n; i++) {
        if (F[i] > max) max = F[i];
    }

    float diff = max - min;

    for (int i = 0; i < n; i++) {
        Fmod[i] = (max - F[i]) / diff;
    }

}

///////////////////////


void linear_priority(float u[2], float F1[n], float F2[n], float res[n]) {

    for (int i = 0; i < n; i++) {

    res[i] = u[0] * F1[i] + u[1] * F2[i];

    }

}

float summar_efficiency(float u[2], float F[n]) { //option1

    float mod_min1[n] = {};
    float mod_min2[n] = {};

    for (int i = 0; i < n; i++) {
        mod_min1[i] = F[i] * u[0];
        mod_min2[i] = F[i] * u[1];
    }

    float min1 = mod_min1[0];  //min (f1)
    float min2 = mod_min2[0];  //min (f2)

    for (int i = 0; i < n; i++) {
        if (mod_min1[i] < min1) min1 = mod_min1[i];
        if (mod_min2[i] < min2) min2 = mod_min2[i];
    }

    if (min1 < min2) return min1; //return min of min
    else return min2;

}

float guarantee_result(float u[2], float F[n]) { //option2
    float mod_min1[n] = {};
    float mod_min2[n] = {};

    for (int i = 0; i < n; i++) {
        mod_min1[i] = F[i] * u[0];
        mod_min2[i] = F[i] * u[1];
    }

    float max1 = mod_min1[0];  //max (f1)
    float max2 = mod_min2[0];  //max (f2)

    for (int i = 0; i < n; i++) {
        if (mod_min1[i] > max1) max1 = mod_min1[i];
        if (mod_min2[i] > max2) max2 = mod_min2[i];
    }

    if (max1 < max2) return max1; //return min of max
    else return max2;

}

int main() {

    //I4 & I5

    //FOR var1 | зміна інгредієнта -d (q from k), лінійний принцип .. сумарна ефективність

    float u1[2] = {0.5, 0.5}; 

    change_ingredient_norm(F, f);
    linear_priority(u1, F1, F2, res)
    summar_efficiency(u1, F);


    //FOR var2 | зміна інгредієнта -d (q from k), лінійний принцип .. гарантований результат

    float u2[2] = {0.5, 0.5};
    change_ingredient_norm(F, f);
    linear_priority(u2, F1, F2, res)
    guarantee_result(u4, f);

    //FOR var3 | відносна (f (q from k) / min f (q from k)), лінійний принцип .. сумарна ефективність

    float u3[2] = {0.4, 0.6};

    dependable_norm(F, f);
    linear_priority(u3, F1, F2, res)
    summar_efficiency(u3, F);

    //FOR var4 | савіджа, лінійний принцип .. гарантований результат

    float u4[2] = {0.3, 0.7};

    savidzh(F, f);
    linear_priority(u4, F1, F2, res)
    guarantee_result(u4, f);

    return 0;
}
